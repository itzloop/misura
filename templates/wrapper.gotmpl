{{- $wn := printf "%sPrometheusWrapperImpl" .WrapperTypeName}}
// Code generated by github.com/itzloop/promwrapgen. DO NOT EDIT!
// RANDOM_HEX={{ .RandomHex }}
// This is used to avoid name colision. Storing this and then
// using it will help us avoid unnecessary changes that will
// pollute git changes.
package {{ .PackageName }}

{{ .Imports }}

// {{$wn}} wraps {{ .WrapperTypeName }} and adds metrics like:
// 1. success count
// 2. error count
// 3. total count
// 4. duration
type {{$wn}} struct {
    // TODO what are fields are required
    intr string
    wrapped {{.WrapperTypeName}}
    metrics interface{
        // Failure will be called when err != nil passing the duration and err to it
        Failure(ctx context.Context, pkg, intr, method string, duration time.Duration, err error)

        // Success will be called if err == nil passing the duration to it
        Success(ctx context.Context, pkg, intr, method string,duration time.Duration)

        // Total will be called as soon as the function is called.
        Total(ctx context.Context, pkg, intr, method string)
    }
}

func New{{$wn}}(
    wrapped {{.WrapperTypeName}},
    metrics interface{
        Failure(ctx context.Context, pkg, intr, method string, duration time.Duration, err error)
        Success(ctx context.Context, pkg, intr, method string,duration time.Duration)
        Total(ctx context.Context, pkg, intr, method string)
    },
) *{{$wn}} {
    var intr string
    splited := strings.Split(fmt.Sprintf("%T", wrapped), ".")
    if len(splited) != 2 {
        intr = "{{ $.WrapperTypeName }}"
    } else {
        intr = splited[1]
    }

    return &{{$wn}}{ 
        intr:    intr,
        wrapped: wrapped,
        metrics: metrics,
    }
}

{{range .MethodList }}
// {{ .MethodName }} wraps another instance of {{ $.WrapperTypeName }} and 
// adds prometheus metrics. See {{ .MethodName }} on {{$wn}}.wrapped for 
// more information.
func (w *{{$wn}}) {{ .MethodSigFull }} {
    {{- if .HasError }}
    // TODO time package conflicts
    start{{ $.RandomHex }} := time.Now()
    {{- end }}

{{- if .HasCtx }}
    w.metrics.Total({{ .Ctx }}, "{{ $.PackageName }}", w.intr, "{{ .MethodName }}")
{{- else }}
    w.metrics.Total(context.Background(), "{{ $.PackageName }}", w.intr, "{{ .MethodName }}")
{{- end}}
{{- if eq .ResultNames "" }}
    w.wrapped.{{.MethodName}}({{ .MethodParamNames }})
{{- else if .NamedResults }}
    {{.ResultNames }} = w.wrapped.{{.MethodName}}({{ .MethodParamNames }})
{{- else }}
    {{.ResultNames }} := w.wrapped.{{.MethodName}}({{ .MethodParamNames }})
{{- end}}
{{- if .HasError }}
{{- duration := join duration $.RandomHex -}}
    {{ $duration }} := time.Since({{$.StartTimeName}})
    if err != nil {
    {{- if .HasCtx }}
        w.metrics.Failure({{ .Ctx }}, "{{ $.PackageName }}", w.intr, "{{ .MethodName }}", {{ $duration }}, err)
    {{- else }}
        w.metrics.Failure(context.Background(), "{{ $.PackageName }}", w.intr, "{{ .MethodName }}", {{ $duration }}, err)
    {{- end}}
        // TODO find a way to add default values here and return the error. for now return the same thing :)
        return {{.ResultNames }}
    }

    // TODO if method has no error does success matter or not?
    {{- if .HasCtx }}
        w.metrics.Success({{ .Ctx }}, "{{ $.PackageName }}", w.intr, "{{ .MethodName }}", {{ $duration }})
    {{- else }}
        w.metrics.Success(context.Background(), "{{ $.PackageName }}", w.intr, "{{ .MethodName }}", {{ $duration }})
    {{- end}}
{{- end }}

    return {{.ResultNames }}
}
{{ end }}
