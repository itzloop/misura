// Code generated by github.com/itzloop/misura. DO NOT EDIT!
// RANDOM_HEX=2C37461E
// This is used to avoid name colision. Storing this and then
// using it will help us avoid unnecessary changes that will
// pollute git changes.
package main

import (
	"context"
	"fmt"
	"net"
	"strings"
	"time"
)

// IPUtilPrometheusWrapperImpl wraps IPUtil and adds metrics like:
// 1. success count
// 2. error count
// 3. total count
// 4. duration
type IPUtilPrometheusWrapperImpl struct {
	// TODO what are fields are required
	name    string
	intr    string
	wrapped IPUtil
	metrics interface {
		// Failure will be called when err != nil passing the duration and err to it
		Failure(ctx context.Context, name, pkg, intr, method string, duration time.Duration, err error)
		// Success will be called if err == nil passing the duration
		Success(ctx context.Context, name, pkg, intr, method string, duration time.Duration)
		// Total will be called as soon as the function is called.
		Total(ctx context.Context, name, pkg, intr, method string)
	}
}

func NewIPUtilPrometheusWrapperImpl(
	name string,
	wrapped IPUtil,
	metrics interface {
		// Failure will be called when err != nil passing the duration and err to it
		Failure(ctx context.Context, name, pkg, intr, method string, duration time.Duration, err error)
		// Success will be called if err == nil passing the duration
		Success(ctx context.Context, name, pkg, intr, method string, duration time.Duration)
		// Total will be called as soon as the function is called.
		Total(ctx context.Context, name, pkg, intr, method string)
	},
) *IPUtilPrometheusWrapperImpl {
	var intr string
	splited := strings.Split(fmt.Sprintf("%T", wrapped), ".")
	if len(splited) != 2 {
		intr = "IPUtil"
	} else {
		intr = splited[1]
	}

	return &IPUtilPrometheusWrapperImpl{
		name:    name,
		intr:    intr,
		wrapped: wrapped,
		metrics: metrics,
	}
}

// PublicIP wraps another instance of IPUtil and
// adds prometheus metrics. See PublicIP on IPUtilPrometheusWrapperImpl.wrapped for
// more information.
func (w *IPUtilPrometheusWrapperImpl) PublicIP() (net.IP, error) {
	// TODO time package conflicts
	start2C37461E := time.Now()
	w.metrics.Total(context.Background(), w.name, "main", w.intr, "PublicIP")
	a, err := w.wrapped.PublicIP()
	duration2C37461E := time.Since(start2C37461E)
	if err != nil {
		w.metrics.Failure(context.Background(), w.name, "main", w.intr, "PublicIP", duration2C37461E, err)
		// TODO find a way to add default values here and return the error. for now return the same thing :)
		return a, err
	}
	w.metrics.Success(context.Background(), w.name, "main", w.intr, "PublicIP", duration2C37461E)

	return a, err
}

// LocalIPs wraps another instance of IPUtil and
// adds prometheus metrics. See LocalIPs on IPUtilPrometheusWrapperImpl.wrapped for
// more information.
func (w *IPUtilPrometheusWrapperImpl) LocalIPs() ([]net.IP, error) {
	// TODO time package conflicts
	start2C37461E := time.Now()
	w.metrics.Total(context.Background(), w.name, "main", w.intr, "LocalIPs")
	a, err := w.wrapped.LocalIPs()
	duration2C37461E := time.Since(start2C37461E)
	if err != nil {
		w.metrics.Failure(context.Background(), w.name, "main", w.intr, "LocalIPs", duration2C37461E, err)
		// TODO find a way to add default values here and return the error. for now return the same thing :)
		return a, err
	}
	w.metrics.Success(context.Background(), w.name, "main", w.intr, "LocalIPs", duration2C37461E)

	return a, err
}
